# auth.py — Интерфейсы аутентификации (Порты)

**Путь:** `v1.5_PracticeRaptor/core/ports/auth.py`

Этот файл определяет **как система взаимодействует** с внешними службами аутентификации. Он содержит только "контракты" (интерфейсы) — что должно быть сделано, но не как.

---

## Ключевая конструкция: `Protocol`

```python
from typing import Protocol

class IAuthProvider(Protocol):
    # ...
```

**Аналогия:** Представь, что это **спецификация разъема USB**. Она говорит: "Вот какие контакты есть, вот что они делают". Но она не говорит, как именно выглядит провод или чип внутри флешки.

`Protocol` в Python позволяет определять интерфейсы, которым должны соответствовать классы. Класс, который "реализует" протокол, не обязательно должен явно наследоваться от него; достаточно, чтобы он имел те же методы с теми же сигнатурами.

---

## `AuthError` — Ошибка аутентификации

```python
from core.domain.errors import DomainError

class AuthError(DomainError):
    """Ошибка аутентификации/авторизации."""
    pass
```

Это специализированный тип ошибки, который сигнализирует о проблемах, связанных с аутентификацией или авторизацией пользователя. Наследуется от `DomainError`, что означает, что это бизнес-логическая ошибка.

---

## `IAuthProvider` — Интерфейс провайдера аутентификации

```python
from typing import Protocol, Any
from core.domain.models import User
from core.domain.result import Result
from core.domain.errors import AuthError

class IAuthProvider(Protocol):
    """Интерфейс для аутентификации."""

    def get_current_user(self) -> Result[User, AuthError]:
        """
        Получить текущего аутентифицированного пользователя.

        Возвращает:
            Result с User в случае успеха или AuthError, если не аутентифицирован
        """
        ...

    def authenticate(self, credentials: dict[str, Any]) -> Result[User, AuthError]:
        """
        Аутентифицировать пользователя по учетным данным.

        Аргументы:
            credentials: Учетные данные для аутентификации (формат зависит от провайдера)

        Возвращает:
            Result с User в случае успеха или AuthError в случае неудачи
        """
        ...
```

**Аналогия:** Это как **паспортный контроль в аэропорту**. Есть две основные операции:
1. **`get_current_user`**: Проверить, кто уже прошел контроль (текущий пользователь). Если никого нет, то сообщаем об ошибке.
2. **`authenticate`**: Пройти контроль с документами (учетными данными). Если все в порядке, даем добро на вход.

**Зачем это нужно?**
- **Разделение ответственности:** Основная логика приложения не зависит от конкретного способа аутентификации (например, логин/пароль, OAuth, JWT).
- **Гибкость:** Можно легко менять или добавлять новые методы аутентификации, не затрагивая остальную часть системы.
- **Тестирование:** Можно "подделывать" (mock) провайдер аутентификации для тестов, имитируя различные сценарии.
